1.Какво означава двоично наредено дърво да бъде изродено, 
обяснете как израждането влияе върху операциите с дървото?

Изродено е двоично нареденото дърво, за което всеки вътрешен възел има само едно дете. Изродените 
дървета са същите като свързания списък.
Ако дървото е изродено, то операциите за търсене, триене  и вмъкване от произволна позиция ще са О(n).

2.В обшия случай кои от следните са предимства на балансираните двоични наредени дървета пред хешовете?

-ако искаме да обходим съхранените елементи в нарастващ ред е по бързо в дърво
-ако искаме стойност N и искаме да намерим най-близкия по стойност елемент съхранен в структурата, става по бързо в дърво
-ако искаме да намерим всички елементи от интервал [a,b], които се съдуржат в структурата, това става по-бързо в дърво

3.Коя структура да използваме за намиране на к-ти най-малък елемент за О(1), намиране на к-ти най-голям елемент за О(1),
търсене за произволен елемент < О(logn) ?

-Сортиран динамичен масив

4.Ако трябва да намерим най-евтиния път (като сума от теглата които съдържа) в даден граф ,можем ли да използваме за
тази цел алгоритъм за търсене в широчина (BFS)?

-Лъжа.

5.Какви са предимствата на хешовете пред дърветата при добавяне и търсене на елелемент?

- Добавяне на елемент в дърво трябва да се обходят елементите му, докато в хешовете добавянето е за константно време,
тъй като елемента минава през хеш функцията и се добавя.
- Търсене на елемент в дърво трябва да се обходят елементите, докато в хешовете се извлича за константно време по специалния ключ.

Посочете поне няколко предимства на дърветата пред хешовете?

-В дървото има последователност на елементите, докато в хешовете няма.
-Ако нямаме ключ, търсенето в дърво става по-бързо за разлика от хешовете.

6.Обяснете  как се отразява data locality на операциите със свързан списък.
Обяснете какъв е ефектът върху основните операции и коментирайте дали той е положителен или негативен.

- При свързан списък data locality има негативен ефект при оперциите ,които се извътршват, защото 
елементите на свързания списък са разпръснати в паметта.

7. При merge sort се изисква О(n) допълнителна памет. (заради заделянията на масиви)

8.Искаме да реализираме стек чрез свързано представяне, използващо структури от вида:
struct Element{
	int Data;
	Element* pNext;
}
Вярно ли е че може да релизираме стек така, че както добавянето на ел (push), така и изваждането на ел. (pop) да
бъдат за О(1) ? 

ДА!

9. Нека в опашка поред сме добавили числата 10,20,30,40 и накрая 50. Можем ли да извадим числото 30 от опашката?

Да, но първо трябва да извадим 10 и 20.

10.Разширяването на динамична, последователна опашка при добавяне е идентично с раширяване на динамичен масив?

Лъжа!!!(трябва да внимаваме с индексите в опашката)

11.Какво е приоритетна опашка?

Абстрактен тип данни представляващ множество от елементи върху ,които има приоритет
поддържат се следните операции: извличане на максималния елемент (+ изтриването му) и вмъкване

12. Нека е дадена опашка, която съхранява елементите си в динамичен масив. Тя е реализирана по стандртната схема, при която
ако запълним масива до негория край, а в началото му има свободно място, "превъртаме" края на опашката така, че 
запълването дапродължи използвайки свободните позиции.Знаем че при тази схема е възможно индексът на края
на опашката са е по-малък от индекса на нейното начало.???(не се виждаше продължението на въпроса)

13.При реализация на структура от данни,която ще изисква често добавяне и премахване на елементи на произволна 
позици, двусвързания списък е за предпочитане пред динамичния масив при голям размер.

Истина

14.Какво се има в предвид под пространствена сложност на даден алгоритъм?

Общото количестно памет, което се използва за да може алгоритъма да работи.

15.Ако опашка имплементирана с масив (изчислява къде е индексът на първия елемент), бъде препълнена, може ли да
се преоразмери? и каква ще бъде сложността на добавянето на елемент в общия случай?

ДА,може. Сложността на добавянето ще бъде амортизирано О(1).

16.Извличането на елемент от свързана опашка е идентично като реализация с извличането от свързан стек.

Истина.

17. Вярно твърдение за Heap Sort:

Сложността му винаги е О(nLogn)

18. Динамичния масив винаги изисква по-малко памет от едносвързания списък? 

Лъжа

19. Коя от структурите данни ще използва повече памет, за да съхрани N елемента от тип int?

Свързания списък (заради допълнителната памет която заделя за адреса на следващия ел.)

20. Нека е дадено следното свързано представяне на стек:
//двойна кутия 
struct Box {
	int Data; // curr element
	Box* pNext; // next element
};

//представяне на стек
struct Stack {
	Box* pTop; // top of stack
	size_t Size; //number of elements in stack
};

Вярно ли е ,че при това представяне можем да реализираме всички стандартни операции на стека (pop,push,peek,getSize)
със сложност О(1)? 

Истина!!!

21. Кое от следните две се рализира понякога като адаптер чрез останалите две?

Стек! (масив + свързан списък)

22.Ако при имплементиране на свързана опашка използваме само един указател (към началото) имплементацията на коя
операция не може да стане според дефиницията на опашка?

enqueue ще се изпълнява за константно време ,което не следва дефиницията.

23. Кои от следните операции не е нужно да се имплементират за пълнофункционална опашка?

-contains
-operator==
-print
-getSize
-isFull

24.При реализация на структура от данни, която ще изисква често добавяне и премахване на елементи 
на произволна позиция , двусвързания списък е за предпочитане пред динамичния масив при голям размер.

Истина

25.Коя сортировка прави най-малко възможен брой размествания на елементи в масив?

Selection sort.

26. Кои от следните операции свързания списък има предимство пред динамичния масив?

-Премахване на елемент в началото
-Изтриване на произволен елемент
-добавяне на елемент в началото
-конкатенация на два списъка/масива

27. Кои от операциите не е нужно да се имплементират при пълнофункционален стек?

-top
-getSize
-print

28. Top / Peek в стек сръща стойността на или дава достатъп до елемента ,който се намира на върха на стека.

29. Посочете каква е сложността на Insertion sort в най добрия случай.Обосновете отговора си?

Сложността в най-добрия случай ще е О(n), тоест когато всички елементи са вече сортирани. Ако всеки елемент е на мястото си
няма да има нито едно влизане в while-цикъла, който премества текущия елемент на правилната позиция, проверявайки дали текущия е 
по малък от предходния.

30. Предимства на динамичен масив пред свързан списък.

Елементите му са разположени последователно в паметта, което води до по-добро бързодействие.
При динамичния масив можем да достъпим елемент на произволен индекс за константно време О(1).
Ако списъкът не пази връзка към последния елемент, то добавянето на елемент на последната 
позиция ще има линейна сложност О(n), докато при динамичня тази сложност би била константна О(1)
амортизирано (понеже може да се наложи преоразмеряване).

31.Трябва да създадем контейнер, за който имаме следните изисквания:
	1.да можем да добавяме произволен брой ел в контейнера.
	2.добавянето да бъде със сложност О(1) (може амортизирана)
	3.няма нужда елементите да се поддържат в някакъв определен ред.
Може да използваме:

-Динамичен масив
-хеш
-свързан списък с две връзки
-свързан списък с една връзка (ако има указател към последния елемент)
